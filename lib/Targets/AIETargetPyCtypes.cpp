//===- AIETargetPyWrapper.cpp -----------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2021 Xilinx Inc.
//
//===----------------------------------------------------------------------===//

#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/IR/Location.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Target/LLVMIR/Import.h"
#include "mlir/Tools/mlir-translate/MlirTranslateMain.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/Transforms/Passes.h"

#include "llvm/ADT/StringExtras.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/TargetSelect.h"

#include "aie/AIENetlistAnalysis.h"
#include "aie/Dialect/AIE/IR/AIEDialect.h"
#include "aie/Dialect/AIEX/IR/AIEXDialect.h"

#include "AIETargets.h"

using namespace mlir;
using namespace xilinx;
using namespace xilinx::AIE;
using namespace xilinx::AIEX;

namespace xilinx {
namespace AIE {

mlir::LogicalResult AIETranslateToPyCtypes(ModuleOp module, raw_ostream &output) {

  DenseMap<std::pair<int, int>, Operation *> tiles;
  DenseMap<Operation *, CoreOp> cores;
  DenseMap<Operation *, MemOp> mems;
  DenseMap<std::pair<Operation *, int>, LockOp> locks;
  DenseMap<Operation *, SmallVector<BufferOp, 4>> buffers;
  DenseMap<Operation *, SwitchboxOp> switchboxes;

  NetlistAnalysis NL(module, tiles, cores, mems, locks, buffers, switchboxes);
  NL.collectTiles(tiles);
  NL.collectBuffers(buffers);

  std::string module_name("AieInc");
  if (auto name = module.getName())
    module_name = *name;

  //---------------------------------------------------------------------------
  // top level
  //---------------------------------------------------------------------------
  output << "# Autogenerated - Do Not Edit\n";
  output << "import ctypes\n";
  output << "\n";
  output << "class " << module_name << ":\n";
  output << "  def __init__(self, filename):\n";
  output << "    self.aie_inc = ctypes.CDLL(filename, mode=ctypes.RTLD_GLOBAL)\n";
  output << "\n"
    "  ##\n"
    "  ## from test_library.cpp (static)\n"
    "  ##\n"
    "\n"
    "  def init(self):\n"
    "    self.aie_inc.mlir_aie_init_libxaie.argtypes = []\n"
    "    r = self.aie_inc.mlir_aie_init_libxaie()\n"
    "    return r\n"
    "\n"
    "  def init_device(self, ctx):\n"
    "    self.aie_inc.mlir_aie_init_device.argtypes = [ctypes.c_void_p]\n"
    "    r = self.aie_inc.mlir_aie_init_device(ctx)\n"
    "    return int(r)\n"
    "\n"
    "  def clear_tile_memory(self, ctx, col, row):\n"
    "    self.aie_inc.mlir_aie_clear_tile_memory.argtypes = \\\n"
    "        [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]\n"
    "    self.aie_inc.mlir_aie_clear_tile_memory(ctx, col, row)\n"
    "\n";

  output << "\n"
    "  ##\n"
    "  ## from aie_inc.cpp (static)\n"
    "  ##\n"
    "\n";

  //---------------------------------------------------------------------------
  // mlir_aie_configure_cores
  //---------------------------------------------------------------------------
  output << "\n"
    "  def configure_cores(self, ctx):\n"
    "    self.aie_inc.mlir_aie_configure_cores.argtypes = [ctypes.c_void_p]\n"
    "    self.aie_inc.mlir_aie_configure_cores(ctx)\n";

  //---------------------------------------------------------------------------
  // mlir_aie_start_cores
  //---------------------------------------------------------------------------
  output << "\n"
    "  def start_cores(self, ctx):\n"
    "    self.aie_inc.mlir_aie_start_cores.argtypes = [ctypes.c_void_p]\n"
    "    self.aie_inc.mlir_aie_start_cores(ctx)\n";
  
  //---------------------------------------------------------------------------
  // mlir_aie_configure_dmas
  //---------------------------------------------------------------------------
  output << "\n"
    "  def configure_dmas(self, ctx):\n"
    "    self.aie_inc.mlir_aie_configure_dmas.argtypes = [ctypes.c_void_p]\n"
    "    self.aie_inc.mlir_aie_configure_dmas(ctx)\n";

  //---------------------------------------------------------------------------
  // mlir_aie_initialize_locks
  //---------------------------------------------------------------------------
  output << "\n"
    "  def initialize_locks(self, ctx):\n"
    "    self.aie_inc.mlir_aie_initialize_locks.argtypes = [ctypes.c_void_p]\n"
    "    self.aie_inc.mlir_aie_initialize_locks(ctx)\n";

  //---------------------------------------------------------------------------
  // mlir_aie_configure_switchboxes
  //---------------------------------------------------------------------------
  output << "\n"
    "  def configure_switchboxes(self, ctx):\n"
    "    self.aie_inc.mlir_aie_configure_switchboxes.argtypes = \\\n"
    "        [ctypes.c_void_p]\n"
    "    self.aie_inc.mlir_aie_configure_switchboxes(ctx)\n";

  //---------------------------------------------------------------------------
  // Output Buffer Accessors
  //---------------------------------------------------------------------------
  for (auto tile : tiles) {
    Operation *tileOp = tile.second;

    for (auto buf : buffers[tileOp]) {
      std::string bufName(buf.name().getValue());
      Type t = buf.getType();
      std::string typestr;
      auto memrefType = t.dyn_cast<MemRefType>();
      if (!memrefType)
        continue;

      Type et = memrefType.getElementType();
      if (et.isInteger(32))
        typestr = "ctypes.c_int32";
      else if (et.isF32())
        typestr = "ctypes.c_float";

      if (!typestr.size()) {
        output << "# buffer " << bufName << " with unsupported type " << t
               << "\n";
        continue;
      }

      output << "\n"
        "  def read_buffer_" << bufName << "(self, ctx, index):\n"
        "    self.aie_inc.mlir_aie_read_buffer_" << bufName << ".argtypes = [ctypes.c_void_p, ctypes.c_int32]\n"
        "    r = self.aie_inc.mlir_aie_read_buffer_" << bufName << "(ctx, index)\n";
      if (et.isInteger(32))
        output << "    return int(r)\n";
      else if (et.isF32())
        output << "    return float(r)\n";

      output << "\n"
        "  def write_buffer_" << bufName << "(self, ctx, index, value):\n"
        "    self.aie_inc.mlir_aie_write_buffer_" << bufName << ".argtypes = [ctypes.c_void_p, ctypes.c_int32, " << typestr << "]\n"
        "    self.aie_inc.mlir_aie_write_buffer_" << bufName << "(ctx, index, value)\n"
        "    return\n";
    }

  }

  // auto lockAccessor = [&](LockOp lock) {
  //   int col = lock.colIndex();
  //   int row = lock.rowIndex();
  //   if (!lock.hasName())
  //     return;
  //   std::string lockName(lock.name().getValue());
  //   output << "int mlir_aie_acquire_" << lockName << "(" << ctx_p
  //          << ", int value, int timeout) {\n";
  //   output << "  const int id = " << lock.getLockIDValue() << ";\n";
  //   output << "  return XAie_LockAcquire(" << deviceInstRef << ", "
  //          << tileLocStr(col, row) << ", " << tileLockStr("id", "value")
  //          << ", timeout);\n";
  //   output << "}\n";
  //   output << "int mlir_aie_release_" << lockName << "(" << ctx_p
  //          << ", int value, int timeout) {\n";
  //   output << "  const int id = " << lock.getLockIDValue() << ";\n";
  //   output << "  return XAie_LockRelease(" << deviceInstRef << ", "
  //          << tileLocStr(col, row) << ", " << tileLockStr("id", "value")
  //          << ", timeout);\n";
  //   output << "}\n";
  // };

  // for (auto lock : module.getOps<LockOp>())
  //   lockAccessor(lock);

  output << "\n";

  return success();
}
} // namespace AIE
} // namespace xilinx
